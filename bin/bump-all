#!/usr/bin/env ruby

bump_version = ARGV[0]

if !bump_version || !['patch', 'minor', 'major'].include?(bump_version)
  puts "Invalid or no version bump specified. Should be one of: patch, minor, major"
  if bump_version
    puts "Version bump supplied: #{bump_version}"
  end
  return
end

packages=%w(
  bullet_train
  bullet_train-api
  bullet_train-fields
  bullet_train-has_uuid
  bullet_train-incoming_webhooks
  bullet_train-integrations
  bullet_train-integrations-stripe
  bullet_train-obfuscates_id
  bullet_train-outgoing_webhooks
  bullet_train-roles
  bullet_train-scope_questions
  bullet_train-scope_validator
  bullet_train-sortable
  bullet_train-super_load_and_authorize_resource
  bullet_train-super_scaffolding
  bullet_train-themes
  bullet_train-themes-light
  bullet_train-themes-tailwind_css
)

# First we run `bump` at the top level, this acts as the authorative gem version.
# We have a fake version file in `lib`, just to keep `bump` happy.

puts "bumping core & CHANGELOG"
puts output = `bump #{bump_version} --tag`
version = output.chomp.lines.last.chomp
puts "Bumped to #{version}."

# Now we bump each of the sub gems
packages.each do |package|
  puts "bumping package: #{package}"
  Dir.chdir "./#{package}"
  puts output = `bump #{bump_version}`
  Dir.chdir ".."
end

puts "the last version = #{version}"

npm_packages=%w(
  bullet_train
  bullet_train-fields
  bullet_train-sortable
)

# And now we munge the package.json files
npm_packages.each do |package|
  puts "bumping npm package: #{package}"
  Dir.chdir "./#{package}"

  text = File.read("package.json")
  new_contents = text.gsub(/"version": ".*"/, "\"version\": \"#{version}\"")
  File.open("package.json", "w") { |file| file.puts new_contents }

  Dir.chdir ".."
end

# This block allows us to pass the new bump version out to the workflow.
github_output_file = ENV['GITHUB_OUTPUT']
if github_output_file
  IO.write(github_output_file, "NEW_VERSION_NUMBER=#{version}\n", mode: 'a')
end
